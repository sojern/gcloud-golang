// Code generated by protoc-gen-gogo.
// source: instance.proto
// DO NOT EDIT!

/*
	Package google_bigtable_admin_v2 is a generated protocol buffer package.

	It is generated from these files:
		instance.proto

	It has these top-level messages:
		Instance
		Cluster
*/
package google_bigtable_admin_v2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_bigtable_admin_v21 "github.com/sojern/gcloud-golang/bigtable/internal/common_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

// Possible states of an instance.
type Instance_State int32

const (
	// The state of the instance could not be determined.
	Instance_STATE_NOT_KNOWN Instance_State = 0
	// The instance has been successfully created and can serve requests
	// to its tables.
	Instance_READY Instance_State = 1
	// The instance is currently being created, and may be destroyed
	// if the creation process encounters an error.
	Instance_CREATING Instance_State = 2
)

var Instance_State_name = map[int32]string{
	0: "STATE_NOT_KNOWN",
	1: "READY",
	2: "CREATING",
}
var Instance_State_value = map[string]int32{
	"STATE_NOT_KNOWN": 0,
	"READY":           1,
	"CREATING":        2,
}

func (x Instance_State) String() string {
	return proto.EnumName(Instance_State_name, int32(x))
}
func (Instance_State) EnumDescriptor() ([]byte, []int) { return fileDescriptorInstance, []int{0, 0} }

// Possible states of a cluster.
type Cluster_State int32

const (
	// The state of the cluster could not be determined.
	Cluster_STATE_NOT_KNOWN Cluster_State = 0
	// The cluster has been successfully created and is ready to serve requests.
	Cluster_READY Cluster_State = 1
	// The cluster is currently being created, and may be destroyed
	// if the creation process encounters an error.
	// A cluster may not be able to serve requests while being created.
	Cluster_CREATING Cluster_State = 2
	// The cluster is currently being resized, and may revert to its previous
	// node count if the process encounters an error.
	// A cluster is still capable of serving requests while being resized,
	// but may exhibit performance as if its number of allocated nodes is
	// between the starting and requested states.
	Cluster_RESIZING Cluster_State = 3
	// The cluster has no backing nodes. The data (tables) still
	// exist, but no operations can be performed on the cluster.
	Cluster_DISABLED Cluster_State = 4
)

var Cluster_State_name = map[int32]string{
	0: "STATE_NOT_KNOWN",
	1: "READY",
	2: "CREATING",
	3: "RESIZING",
	4: "DISABLED",
}
var Cluster_State_value = map[string]int32{
	"STATE_NOT_KNOWN": 0,
	"READY":           1,
	"CREATING":        2,
	"RESIZING":        3,
	"DISABLED":        4,
}

func (x Cluster_State) String() string {
	return proto.EnumName(Cluster_State_name, int32(x))
}
func (Cluster_State) EnumDescriptor() ([]byte, []int) { return fileDescriptorInstance, []int{1, 0} }

// A collection of Bigtable [Tables][google.bigtable.admin.v2.Table] and
// the resources that serve them.
// All tables in an instance are served from a single
// [Cluster][google.bigtable.admin.v2.Cluster].
type Instance struct {
	// @OutputOnly
	// The unique name of the instance. Values are of the form
	// projects/<project>/instances/[a-z][a-z0-9\\-]+[a-z0-9]
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The descriptive name for this instance as it appears in UIs.
	// Can be changed at any time, but should be kept globally unique
	// to avoid confusion.
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	//
	// The current state of the instance.
	State Instance_State `protobuf:"varint,3,opt,name=state,proto3,enum=google.bigtable.admin.v2.Instance_State" json:"state,omitempty"`
}

func (m *Instance) Reset()                    { *m = Instance{} }
func (m *Instance) String() string            { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()               {}
func (*Instance) Descriptor() ([]byte, []int) { return fileDescriptorInstance, []int{0} }

// A resizable group of nodes in a particular cloud location, capable
// of serving all [Tables][google.bigtable.admin.v2.Table] in the parent
// [Instance][google.bigtable.admin.v2.Instance].
type Cluster struct {
	// @OutputOnly
	// The unique name of the cluster. Values are of the form
	// projects/<project>/instances/<instance>/clusters/[a-z][-a-z0-9]*
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// @CreationOnly
	// The location where this cluster's nodes and storage reside. For best
	// performance, clients should be located as close as possible to this cluster.
	// Currently only zones are supported, e.g. projects/*/locations/us-central1-b
	Location string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	// @OutputOnly
	// The current state of the cluster.
	State Cluster_State `protobuf:"varint,3,opt,name=state,proto3,enum=google.bigtable.admin.v2.Cluster_State" json:"state,omitempty"`
	// The number of nodes allocated to this cluster. More nodes enable higher
	// throughput and more consistent performance.
	ServeNodes int32 `protobuf:"varint,4,opt,name=serve_nodes,json=serveNodes,proto3" json:"serve_nodes,omitempty"`
	// @CreationOnly
	// The type of storage used by this cluster to serve its
	// parent instance's tables, unless explicitly overridden.
	DefaultStorageType google_bigtable_admin_v21.StorageType `protobuf:"varint,5,opt,name=default_storage_type,json=defaultStorageType,proto3,enum=google.bigtable.admin.v2.StorageType" json:"default_storage_type,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorInstance, []int{1} }

func init() {
	proto.RegisterType((*Instance)(nil), "google.bigtable.admin.v2.Instance")
	proto.RegisterType((*Cluster)(nil), "google.bigtable.admin.v2.Cluster")
	proto.RegisterEnum("google.bigtable.admin.v2.Instance_State", Instance_State_name, Instance_State_value)
	proto.RegisterEnum("google.bigtable.admin.v2.Cluster_State", Cluster_State_name, Cluster_State_value)
}
func (m *Instance) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Instance) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintInstance(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.DisplayName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintInstance(data, i, uint64(len(m.DisplayName)))
		i += copy(data[i:], m.DisplayName)
	}
	if m.State != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintInstance(data, i, uint64(m.State))
	}
	return i, nil
}

func (m *Cluster) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Cluster) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintInstance(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Location) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintInstance(data, i, uint64(len(m.Location)))
		i += copy(data[i:], m.Location)
	}
	if m.State != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintInstance(data, i, uint64(m.State))
	}
	if m.ServeNodes != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintInstance(data, i, uint64(m.ServeNodes))
	}
	if m.DefaultStorageType != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintInstance(data, i, uint64(m.DefaultStorageType))
	}
	return i, nil
}

func encodeFixed64Instance(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Instance(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintInstance(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Instance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovInstance(uint64(m.State))
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovInstance(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovInstance(uint64(m.State))
	}
	if m.ServeNodes != 0 {
		n += 1 + sovInstance(uint64(m.ServeNodes))
	}
	if m.DefaultStorageType != 0 {
		n += 1 + sovInstance(uint64(m.DefaultStorageType))
	}
	return n
}

func sovInstance(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInstance(x uint64) (n int) {
	return sovInstance(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Instance) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (Instance_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInstance(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstance
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (Cluster_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServeNodes", wireType)
			}
			m.ServeNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ServeNodes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultStorageType", wireType)
			}
			m.DefaultStorageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DefaultStorageType |= (google_bigtable_admin_v21.StorageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInstance(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInstance(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInstance
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInstance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInstance
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInstance
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInstance(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInstance = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInstance   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorInstance = []byte{
	// 409 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x52, 0xcd, 0xca, 0xd3, 0x40,
	0x14, 0x35, 0xfd, 0x1a, 0xed, 0x37, 0xad, 0x35, 0x8c, 0x2e, 0x42, 0x11, 0x7f, 0x02, 0x62, 0x37,
	0x26, 0x50, 0x71, 0x25, 0x0a, 0xfd, 0x09, 0x12, 0x2a, 0x69, 0x4d, 0x02, 0x45, 0x37, 0x61, 0x92,
	0x8c, 0x63, 0x64, 0x32, 0x53, 0x92, 0x49, 0xa1, 0x6f, 0xe6, 0x0b, 0x08, 0x2e, 0x7d, 0x04, 0xf1,
	0x49, 0x9c, 0x4c, 0x53, 0xb1, 0x60, 0x36, 0xdf, 0x62, 0xe0, 0x9e, 0x7b, 0xcf, 0x9c, 0x73, 0x92,
	0xb9, 0x60, 0x9c, 0xb3, 0x4a, 0x20, 0x96, 0x62, 0x7b, 0x5f, 0x72, 0xc1, 0xa1, 0x49, 0x38, 0x27,
	0x14, 0xdb, 0x49, 0x4e, 0x04, 0x4a, 0x64, 0x81, 0xb2, 0x22, 0x67, 0xf6, 0x61, 0x36, 0x59, 0x93,
	0x5c, 0x7c, 0xa9, 0x13, 0x3b, 0xe5, 0x85, 0x53, 0xf1, 0xaf, 0xb8, 0x64, 0x0e, 0x49, 0x29, 0xaf,
	0xb3, 0x17, 0x84, 0x53, 0xc4, 0x88, 0x73, 0xbe, 0xe2, 0xe4, 0x4c, 0xc8, 0x29, 0xa2, 0x8e, 0xa4,
	0x16, 0x9c, 0xc5, 0x4a, 0xb9, 0x05, 0x27, 0x1b, 0xeb, 0x9b, 0x06, 0x06, 0x5e, 0xeb, 0x0c, 0x21,
	0xe8, 0x33, 0x54, 0x60, 0x53, 0x7b, 0xa2, 0x4d, 0xaf, 0x03, 0x55, 0xc3, 0xa7, 0x60, 0x94, 0xe5,
	0xd5, 0x9e, 0xa2, 0x63, 0xac, 0x66, 0x3d, 0x35, 0x1b, 0xb6, 0x3d, 0xbf, 0xa1, 0xbc, 0x05, 0xba,
	0x14, 0x10, 0xd8, 0xbc, 0x92, 0xb3, 0xf1, 0x6c, 0x6a, 0x77, 0x45, 0xb7, 0xcf, 0x4e, 0x76, 0xd8,
	0xf0, 0x83, 0xd3, 0x35, 0xeb, 0x15, 0xd0, 0x15, 0x86, 0xf7, 0xc1, 0xbd, 0x30, 0x9a, 0x47, 0x6e,
	0xec, 0x6f, 0xa2, 0x78, 0xed, 0x6f, 0x76, 0xbe, 0x71, 0x0b, 0x5e, 0x03, 0x3d, 0x70, 0xe7, 0xab,
	0x8f, 0x86, 0x06, 0x47, 0x60, 0xb0, 0x94, 0x75, 0xe4, 0xf9, 0xef, 0x8c, 0x9e, 0xf5, 0xbd, 0x07,
	0xee, 0x2c, 0x69, 0x5d, 0xc9, 0x6f, 0xfc, 0x6f, 0xf2, 0x09, 0x18, 0x50, 0x9e, 0x22, 0x91, 0x73,
	0xd6, 0xa6, 0xfe, 0x8b, 0xe1, 0x9b, 0xcb, 0xc8, 0xcf, 0xbb, 0x23, 0xb7, 0x0e, 0x17, 0x89, 0xe1,
	0x63, 0x30, 0xac, 0x70, 0x79, 0xc0, 0x31, 0xe3, 0x19, 0xae, 0xcc, 0xbe, 0x14, 0xd1, 0x03, 0xa0,
	0x5a, 0x7e, 0xd3, 0x81, 0x3b, 0xf0, 0x20, 0xc3, 0x9f, 0x51, 0x4d, 0x45, 0x5c, 0x09, 0x5e, 0x22,
	0x82, 0x63, 0x71, 0xdc, 0x63, 0x53, 0x57, 0x76, 0xcf, 0xba, 0xed, 0xc2, 0x13, 0x3b, 0x92, 0xe4,
	0x00, 0xb6, 0x12, 0xff, 0xf4, 0xac, 0x0f, 0x37, 0xfa, 0x57, 0x0d, 0x0a, 0xdc, 0xd0, 0xfb, 0xd4,
	0xa0, 0xab, 0x06, 0xad, 0xbc, 0x70, 0xbe, 0x78, 0xef, 0xae, 0x8c, 0xfe, 0xe2, 0xf5, 0x8f, 0xdf,
	0x8f, 0xb4, 0x9f, 0xf2, 0xfc, 0x92, 0x07, 0x3c, 0x94, 0xeb, 0xd1, 0x19, 0x6f, 0x71, 0xf7, 0xfc,
	0x82, 0xdb, 0x66, 0x7b, 0xb6, 0x5a, 0x72, 0x5b, 0xad, 0xd1, 0xcb, 0x3f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0xc7, 0x5d, 0x98, 0x50, 0xbf, 0x02, 0x00, 0x00,
}
